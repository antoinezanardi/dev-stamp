{
  "files": {
    "src/index.ts": {
      "language": "typescript",
      "mutants": [
        {
          "id": "0",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected \"validateBrowserEnvironment\" to be called once with arguments: []\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "25"
          ],
          "coveredBy": [
            "25",
            "26",
            "27",
            "28"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 20
            },
            "start": {
              "column": 101,
              "line": 7
            }
          }
        },
        {
          "id": "1",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/index.ts(9,9): error TS2739: Type '{}' is missing the following properties from type 'Record<StampMode, () => void>': comment, \"meta-tag\"\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "25",
            "26",
            "27",
            "28"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 12
            },
            "start": {
              "column": 55,
              "line": 9
            }
          }
        },
        {
          "id": "2",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "expected \"stampCommentInHtml\" to be called once with arguments: [ 'Hello Dark Jess\\' ðŸª„', â€¦(1) ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 2,
          "static": false,
          "killedBy": [
            "26"
          ],
          "coveredBy": [
            "25",
            "26",
            "27",
            "28"
          ],
          "location": {
            "end": {
              "column": 64,
              "line": 10
            },
            "start": {
              "column": 16,
              "line": 10
            }
          }
        },
        {
          "id": "3",
          "mutatorName": "ArrowFunction",
          "replacement": "() => undefined",
          "statusReason": "expected \"stampMetaTagInHtml\" to be called once with arguments: [ 'Hello Dark Jess\\' ðŸª„', â€¦(1) ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 3,
          "static": false,
          "killedBy": [
            "27"
          ],
          "coveredBy": [
            "25",
            "26",
            "27",
            "28"
          ],
          "location": {
            "end": {
              "column": 65,
              "line": 11
            },
            "start": {
              "column": 17,
              "line": 11
            }
          }
        },
        {
          "id": "4",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected \"validateBrowserEnvironment\" to be called once with arguments: []\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "25"
          ],
          "coveredBy": [
            "25",
            "26",
            "27",
            "28"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 17
            },
            "start": {
              "column": 7,
              "line": 14
            }
          }
        },
        {
          "id": "5",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected \"error\" to be called with arguments: [ Error: Test error ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "28"
          ],
          "coveredBy": [
            "28"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 19
            },
            "start": {
              "column": 19,
              "line": 17
            }
          }
        }
      ],
      "source": "import type { StampMode, StampOptions, StampMetaTagOptions } from \"@/index.types\";\nimport { DEFAULT_STAMP_OPTIONS } from \"@/index.constants\";\nimport { stampCommentInHtml } from \"@/modes/comment/comment\";\nimport { stampMetaTagInHtml } from \"@/modes/meta-tag/meta-tag\";\nimport { getStampOptions, validateBrowserEnvironment } from \"@/utils/utils\";\n\nfunction stampInHtml(message: string, options: Partial<StampOptions> = DEFAULT_STAMP_OPTIONS): void {\n  const mergedOptions = getStampOptions(options);\n  const stampMethods: Record<StampMode, () => void> = {\n    \"comment\": () => stampCommentInHtml(message, mergedOptions),\n    \"meta-tag\": () => stampMetaTagInHtml(message, mergedOptions),\n  };\n\n  try {\n    validateBrowserEnvironment();\n    stampMethods[mergedOptions.mode]();\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nexport {\n  stampInHtml,\n};\n\nexport type {\n  StampOptions,\n  StampMetaTagOptions,\n};"
    },
    "src/modes/comment/comment.ts": {
      "language": "typescript",
      "mutants": [
        {
          "id": "6",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/modes/comment/comment.ts(4,78): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 13
            },
            "start": {
              "column": 85,
              "line": 4
            }
          }
        },
        {
          "id": "7",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected '\\nHello Dark Jess\\' ðŸª„\\n' to be 'Hello Dark Jess\\' ðŸª„' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "18"
          ],
          "coveredBy": [
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 31,
              "line": 6
            },
            "start": {
              "column": 7,
              "line": 6
            }
          }
        },
        {
          "id": "8",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected 'Hello Dark Jess\\' ðŸª„' to be '\\nHello Dark Jess\\' ðŸª„\\n' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 3,
          "static": false,
          "killedBy": [
            "20"
          ],
          "coveredBy": [
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 31,
              "line": 6
            },
            "start": {
              "column": 7,
              "line": 6
            }
          }
        },
        {
          "id": "9",
          "mutatorName": "EqualityOperator",
          "replacement": "innerDisplay !== \"block\"",
          "statusReason": "src/modes/comment/comment.ts(9,7): error TS2367: This comparison appears to be unintentional because the types '\"block\"' and '\"spaced-inline\"' have no overlap.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 31,
              "line": 6
            },
            "start": {
              "column": 7,
              "line": 6
            }
          }
        },
        {
          "id": "10",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "src/modes/comment/comment.ts(6,7): error TS2367: This comparison appears to be unintentional because the types 'CommentInnerDisplay' and '\"\"' have no overlap.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "18",
            "19",
            "20",
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 31,
              "line": 6
            },
            "start": {
              "column": 24,
              "line": 6
            }
          }
        },
        {
          "id": "11",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected 'Hello Dark Jess\\' ðŸª„' to be '\\nHello Dark Jess\\' ðŸª„\\n' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "20"
          ],
          "coveredBy": [
            "20"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 8
            },
            "start": {
              "column": 33,
              "line": 6
            }
          }
        },
        {
          "id": "12",
          "mutatorName": "StringLiteral",
          "replacement": "``",
          "statusReason": "expected '' to be '\\nHello Dark Jess\\' ðŸª„\\n' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "20"
          ],
          "coveredBy": [
            "20"
          ],
          "location": {
            "end": {
              "column": 28,
              "line": 7
            },
            "start": {
              "column": 12,
              "line": 7
            }
          }
        },
        {
          "id": "13",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected ' Hello Dark Jess\\' ðŸª„ ' to be 'Hello Dark Jess\\' ðŸª„' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "18"
          ],
          "coveredBy": [
            "18",
            "19",
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 39,
              "line": 9
            },
            "start": {
              "column": 7,
              "line": 9
            }
          }
        },
        {
          "id": "14",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected 'Hello Dark Jess\\' ðŸª„' to be ' Hello Dark Jess\\' ðŸª„ ' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 2,
          "static": false,
          "killedBy": [
            "19"
          ],
          "coveredBy": [
            "18",
            "19",
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 39,
              "line": 9
            },
            "start": {
              "column": 7,
              "line": 9
            }
          }
        },
        {
          "id": "15",
          "mutatorName": "EqualityOperator",
          "replacement": "innerDisplay !== \"spaced-inline\"",
          "statusReason": "expected ' Hello Dark Jess\\' ðŸª„ ' to be 'Hello Dark Jess\\' ðŸª„' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "18"
          ],
          "coveredBy": [
            "18",
            "19",
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 39,
              "line": 9
            },
            "start": {
              "column": 7,
              "line": 9
            }
          }
        },
        {
          "id": "16",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "src/modes/comment/comment.ts(9,7): error TS2367: This comparison appears to be unintentional because the types '\"inline\" | \"spaced-inline\"' and '\"\"' have no overlap.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "18",
            "19",
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 39,
              "line": 9
            },
            "start": {
              "column": 24,
              "line": 9
            }
          }
        },
        {
          "id": "17",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected 'Hello Dark Jess\\' ðŸª„' to be ' Hello Dark Jess\\' ðŸª„ ' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "19"
          ],
          "coveredBy": [
            "19"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 11
            },
            "start": {
              "column": 41,
              "line": 9
            }
          }
        },
        {
          "id": "18",
          "mutatorName": "StringLiteral",
          "replacement": "``",
          "statusReason": "expected '' to be ' Hello Dark Jess\\' ðŸª„ ' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "19"
          ],
          "coveredBy": [
            "19"
          ],
          "location": {
            "end": {
              "column": 26,
              "line": 10
            },
            "start": {
              "column": 12,
              "line": 10
            }
          }
        },
        {
          "id": "19",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected \"getTargetElement\" to be called with arguments: [ 'body' ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "21"
          ],
          "coveredBy": [
            "21",
            "22",
            "23",
            "24"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 21
            },
            "start": {
              "column": 75,
              "line": 15
            }
          }
        }
      ],
      "source": "import type { StampCommentOptions, StampOptions } from \"@/index.types\";\nimport { getTargetElement } from \"@/utils/utils\";\n\nfunction getFormattedComment(message: string, options: StampCommentOptions): string {\n  const { innerDisplay } = options;\n  if (innerDisplay === \"block\") {\n    return `\\n${message}\\n`;\n  }\n  if (innerDisplay === \"spaced-inline\") {\n    return ` ${message} `;\n  }\n  return message;\n}\n\nfunction stampCommentInHtml(message: string, options: StampOptions): void {\n  const { targetSelector, comment: commentOptions } = options;\n  const targetElement = getTargetElement(targetSelector);\n  const formattedComment = getFormattedComment(message, commentOptions);\n  const commentNode = window.document.createComment(formattedComment);\n  targetElement.appendChild(commentNode);\n}\n\nexport {\n  getFormattedComment,\n  stampCommentInHtml,\n};"
    },
    "src/modes/meta-tag/meta-tag.ts": {
      "language": "typescript",
      "mutants": [
        {
          "id": "20",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected \"setAttribute\" to be called once with arguments: [ 'content', 'Hello Dark Jess\\' ðŸª„' ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "11"
          ],
          "coveredBy": [
            "11",
            "12",
            "17"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 11
            },
            "start": {
              "column": 112,
              "line": 3
            }
          }
        },
        {
          "id": "21",
          "mutatorName": "BooleanLiteral",
          "replacement": "doesOverride",
          "statusReason": "expected \"setAttribute\" to be called once with arguments: [ 'content', 'Hello Dark Jess\\' ðŸª„' ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "11"
          ],
          "coveredBy": [
            "11",
            "12",
            "17"
          ],
          "location": {
            "end": {
              "column": 20,
              "line": 5
            },
            "start": {
              "column": 7,
              "line": 5
            }
          }
        },
        {
          "id": "22",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected \"setAttribute\" to be called once with arguments: [ 'content', 'Hello Dark Jess\\' ðŸª„' ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "11"
          ],
          "coveredBy": [
            "11",
            "12",
            "17"
          ],
          "location": {
            "end": {
              "column": 20,
              "line": 5
            },
            "start": {
              "column": 7,
              "line": 5
            }
          }
        },
        {
          "id": "23",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected \"error\" to be called once with arguments: [ Array(1) ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 2,
          "static": false,
          "killedBy": [
            "12"
          ],
          "coveredBy": [
            "11",
            "12",
            "17"
          ],
          "location": {
            "end": {
              "column": 20,
              "line": 5
            },
            "start": {
              "column": 7,
              "line": 5
            }
          }
        },
        {
          "id": "24",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected \"error\" to be called once with arguments: [ Array(1) ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "12"
          ],
          "coveredBy": [
            "12"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 9
            },
            "start": {
              "column": 22,
              "line": 5
            }
          }
        },
        {
          "id": "25",
          "mutatorName": "StringLiteral",
          "replacement": "``",
          "statusReason": "expected \"error\" to be called once with arguments: [ Array(1) ]\u001b[90m\n\nReceived: \n\n\u001b[1m  1st error call:\n\n\u001b[22m\u001b[2m  [\u001b[22m\n\u001b[32m-   \"Meta tag with name \\\"description\\\" already exists. Use \\\"overwrite\\\" option to replace it.\",\u001b[90m\n\u001b[31m+   \"\",\u001b[90m\n\u001b[2m  ]\u001b[22m\n\u001b[39m\u001b[90m\n\nNumber of calls: \u001b[1m1\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "12"
          ],
          "coveredBy": [
            "12"
          ],
          "location": {
            "end": {
              "column": 111,
              "line": 6
            },
            "start": {
              "column": 19,
              "line": 6
            }
          }
        },
        {
          "id": "26",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Uncaught InvalidCharacterError: Failed to execute 'setAttribute' on 'Element': '' is not a valid attribute name.",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "11"
          ],
          "coveredBy": [
            "11",
            "17"
          ],
          "location": {
            "end": {
              "column": 41,
              "line": 10
            },
            "start": {
              "column": 32,
              "line": 10
            }
          }
        },
        {
          "id": "27",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected \"appendChild\" to be called once with arguments: [ HTMLMetaElement{ â€¦(46) } ]\u001b[90m\n\nNumber of calls: \u001b[1m0\u001b[22m\n\u001b[39m",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "13"
          ],
          "coveredBy": [
            "13",
            "14",
            "15",
            "16",
            "17"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 26
            },
            "start": {
              "column": 75,
              "line": 13
            }
          }
        },
        {
          "id": "28",
          "mutatorName": "StringLiteral",
          "replacement": "``",
          "statusReason": "Failed to execute 'querySelector' on 'HTMLHeadElement': The provided selector is empty.",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "13"
          ],
          "coveredBy": [
            "13",
            "14",
            "15",
            "16",
            "17"
          ],
          "location": {
            "end": {
              "column": 68,
              "line": 16
            },
            "start": {
              "column": 46,
              "line": 16
            }
          }
        },
        {
          "id": "29",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "src/modes/meta-tag/meta-tag.ts(18,37): error TS2345: Argument of type 'Element | null' is not assignable to parameter of type 'Element'.\n  Type 'null' is not assignable to type 'Element'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "13",
            "14",
            "15",
            "16",
            "17"
          ],
          "location": {
            "end": {
              "column": 22,
              "line": 17
            },
            "start": {
              "column": 7,
              "line": 17
            }
          }
        },
        {
          "id": "30",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "src/modes/meta-tag/meta-tag.ts(18,37): error TS2345: Argument of type 'Element | null' is not assignable to parameter of type 'Element'.\n  Type 'null' is not assignable to type 'Element'.\n",
          "status": "CompileError",
          "static": false,
          "killedBy": [],
          "coveredBy": [
            "13",
            "14",
            "15",
            "16",
            "17"
          ],
          "location": {
            "end": {
              "column": 22,
              "line": 17
            },
            "start": {
              "column": 7,
              "line": 17
            }
          }
        },
        {
          "id": "31",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected null to be 'Hello Dark Jess\\' ðŸª„' // Object.is equality",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "17"
          ],
          "coveredBy": [
            "17"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 21
            },
            "start": {
              "column": 24,
              "line": 17
            }
          }
        },
        {
          "id": "32",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Failed to execute 'createElementNS' on 'Document': The qualified name provided is empty.",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "13"
          ],
          "coveredBy": [
            "13",
            "14",
            "15",
            "16"
          ],
          "location": {
            "end": {
              "column": 55,
              "line": 22
            },
            "start": {
              "column": 49,
              "line": 22
            }
          }
        },
        {
          "id": "33",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Uncaught InvalidCharacterError: Failed to execute 'setAttribute' on 'Element': '' is not a valid attribute name.",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "13"
          ],
          "coveredBy": [
            "13",
            "14",
            "15",
            "16"
          ],
          "location": {
            "end": {
              "column": 30,
              "line": 23
            },
            "start": {
              "column": 24,
              "line": 23
            }
          }
        },
        {
          "id": "34",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "Uncaught InvalidCharacterError: Failed to execute 'setAttribute' on 'Element': '' is not a valid attribute name.",
          "status": "Killed",
          "testsCompleted": 1,
          "static": false,
          "killedBy": [
            "13"
          ],
          "coveredBy": [
            "13",
            "14",
            "15",
            "16"
          ],
          "location": {
            "end": {
              "column": 33,
              "line": 24
            },
            "start": {
              "column": 24,
              "line": 24
            }
          }
        }
      ],
      "source": "import type { StampMetaTagOptions, StampOptions } from \"@/index.types\";\n\nfunction stampOnExistingMetaTag(message: string, existingMetaTag: Element, options: StampMetaTagOptions): void {\n  const { overwrite: doesOverride } = options;\n  if (!doesOverride) {\n    console.error(`Meta tag with name \"${options.name}\" already exists. Use \"overwrite\" option to replace it.`);\n\n    return;\n  }\n  existingMetaTag.setAttribute(\"content\", message);\n}\n\nfunction stampMetaTagInHtml(message: string, options: StampOptions): void {\n  const { head } = window.document;\n  const { name } = options.metaTag;\n  const existingMetaTag = head.querySelector(`meta[name=\"${name}\"]`);\n  if (existingMetaTag) {\n    stampOnExistingMetaTag(message, existingMetaTag, options.metaTag);\n\n    return;\n  }\n  const metaTag = window.document.createElement(\"meta\");\n  metaTag.setAttribute(\"name\", name);\n  metaTag.setAttribute(\"content\", message);\n  head.appendChild(metaTag);\n}\n\nexport {\n  stampOnExistingMetaTag,\n  stampMetaTagInHtml,\n};"
    },
    "src/utils/utils.ts": {
      "language": "typescript",
      "mutants": [
        {
          "id": "38",
          "mutatorName": "LogicalOperator",
          "replacement": "typeof window === \"undefined\" && typeof window.document === \"undefined\"",
          "statusReason": "src/utils/utils.ts(5,54): error TS2339: Property 'document' does not exist on type 'never'.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "0",
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 78,
              "line": 5
            },
            "start": {
              "column": 7,
              "line": 5
            }
          }
        },
        {
          "id": "36",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "expected [Function] to not throw an error but 'Error: This function can only be run â€¦' was thrown",
          "status": "Killed",
          "static": false,
          "testsCompleted": 3,
          "killedBy": [
            "2"
          ],
          "coveredBy": [
            "0",
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 78,
              "line": 5
            },
            "start": {
              "column": 7,
              "line": 5
            }
          }
        },
        {
          "id": "35",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "static": false,
          "testsCompleted": 1,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 8
            },
            "start": {
              "column": 45,
              "line": 4
            }
          }
        },
        {
          "id": "37",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "static": false,
          "testsCompleted": 1,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 78,
              "line": 5
            },
            "start": {
              "column": 7,
              "line": 5
            }
          }
        },
        {
          "id": "40",
          "mutatorName": "EqualityOperator",
          "replacement": "typeof window !== \"undefined\"",
          "statusReason": "src/utils/utils.ts(5,54): error TS2339: Property 'document' does not exist on type 'never'.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "0",
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 36,
              "line": 5
            },
            "start": {
              "column": 7,
              "line": 5
            }
          }
        },
        {
          "id": "41",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "src/utils/utils.ts(5,7): error TS2367: This comparison appears to be unintentional because the types '\"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\"' and '\"\"' have no overlap.\nsrc/utils/utils.ts(5,45): error TS2339: Property 'document' does not exist on type 'never'.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "0",
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 36,
              "line": 5
            },
            "start": {
              "column": 25,
              "line": 5
            }
          }
        },
        {
          "id": "39",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [Function] to throw error including 'This function can only be run in a brâ€¦' but got 'Cannot read properties of undefined (â€¦'",
          "status": "Killed",
          "static": false,
          "testsCompleted": 1,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 36,
              "line": 5
            },
            "start": {
              "column": 7,
              "line": 5
            }
          }
        },
        {
          "id": "42",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "static": false,
          "testsCompleted": 1,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 78,
              "line": 5
            },
            "start": {
              "column": 40,
              "line": 5
            }
          }
        },
        {
          "id": "44",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "src/utils/utils.ts(5,40): error TS2367: This comparison appears to be unintentional because the types '\"string\" | \"number\" | \"bigint\" | \"boolean\" | \"symbol\" | \"undefined\" | \"object\" | \"function\"' and '\"\"' have no overlap.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 78,
              "line": 5
            },
            "start": {
              "column": 67,
              "line": 5
            }
          }
        },
        {
          "id": "43",
          "mutatorName": "EqualityOperator",
          "replacement": "typeof window.document !== \"undefined\"",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "static": false,
          "testsCompleted": 1,
          "killedBy": [
            "1"
          ],
          "coveredBy": [
            "1",
            "2"
          ],
          "location": {
            "end": {
              "column": 78,
              "line": 5
            },
            "start": {
              "column": 40,
              "line": 5
            }
          }
        },
        {
          "id": "45",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "expected [Function] to throw an error",
          "status": "Killed",
          "static": false,
          "testsCompleted": 1,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 7
            },
            "start": {
              "column": 80,
              "line": 5
            }
          }
        },
        {
          "id": "46",
          "mutatorName": "StringLiteral",
          "replacement": "\"\"",
          "statusReason": "expected [Function] to throw error including 'This function can only be run in a brâ€¦' but got ''",
          "status": "Killed",
          "static": false,
          "testsCompleted": 1,
          "killedBy": [
            "0"
          ],
          "coveredBy": [
            "0",
            "1"
          ],
          "location": {
            "end": {
              "column": 78,
              "line": 6
            },
            "start": {
              "column": 21,
              "line": 6
            }
          }
        },
        {
          "id": "48",
          "mutatorName": "BooleanLiteral",
          "replacement": "targetElement",
          "statusReason": "src/utils/utils.ts(15,3): error TS2322: Type 'null' is not assignable to type 'Element'.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "3",
            "4"
          ],
          "location": {
            "end": {
              "column": 21,
              "line": 12
            },
            "start": {
              "column": 7,
              "line": 12
            }
          }
        },
        {
          "id": "49",
          "mutatorName": "ConditionalExpression",
          "replacement": "true",
          "statusReason": "src/utils/utils.ts(15,3): error TS2322: Type 'Element | null' is not assignable to type 'Element'.\n  Type 'null' is not assignable to type 'Element'.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "3",
            "4"
          ],
          "location": {
            "end": {
              "column": 21,
              "line": 12
            },
            "start": {
              "column": 7,
              "line": 12
            }
          }
        },
        {
          "id": "47",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/utils/utils.ts(10,52): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "3",
            "4"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 16
            },
            "start": {
              "column": 60,
              "line": 10
            }
          }
        },
        {
          "id": "50",
          "mutatorName": "ConditionalExpression",
          "replacement": "false",
          "statusReason": "src/utils/utils.ts(15,3): error TS2322: Type 'Element | null' is not assignable to type 'Element'.\n  Type 'null' is not assignable to type 'Element'.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "3",
            "4"
          ],
          "location": {
            "end": {
              "column": 21,
              "line": 12
            },
            "start": {
              "column": 7,
              "line": 12
            }
          }
        },
        {
          "id": "51",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/utils/utils.ts(13,3): error TS2322: Type 'Element | null' is not assignable to type 'Element'.\n  Type 'null' is not assignable to type 'Element'.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "3"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 14
            },
            "start": {
              "column": 23,
              "line": 12
            }
          }
        },
        {
          "id": "53",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/utils/utils.ts(18,64): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "5",
            "6",
            "9",
            "10"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 23
            },
            "start": {
              "column": 84,
              "line": 18
            }
          }
        },
        {
          "id": "54",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/utils/utils.ts(19,3): error TS2739: Type '{}' is missing the following properties from type 'StampMetaTagOptions': name, overwrite\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "5",
            "6",
            "9",
            "10"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 22
            },
            "start": {
              "column": 10,
              "line": 19
            }
          }
        },
        {
          "id": "52",
          "mutatorName": "StringLiteral",
          "replacement": "``",
          "statusReason": "expected [Function] to throw error including 'Target element not found: #nonexistent' but got ''",
          "status": "Killed",
          "static": false,
          "testsCompleted": 1,
          "killedBy": [
            "3"
          ],
          "coveredBy": [
            "3"
          ],
          "location": {
            "end": {
              "column": 66,
              "line": 13
            },
            "start": {
              "column": 21,
              "line": 13
            }
          }
        },
        {
          "id": "55",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/utils/utils.ts(25,64): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "7",
            "8",
            "9",
            "10"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 30
            },
            "start": {
              "column": 84,
              "line": 25
            }
          }
        },
        {
          "id": "56",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/utils/utils.ts(26,3): error TS2741: Property 'innerDisplay' is missing in type '{}' but required in type 'StampCommentOptions'.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "7",
            "8",
            "9",
            "10"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 29
            },
            "start": {
              "column": 10,
              "line": 26
            }
          }
        },
        {
          "id": "58",
          "mutatorName": "ObjectLiteral",
          "replacement": "{}",
          "statusReason": "src/utils/utils.ts(33,3): error TS2739: Type '{}' is missing the following properties from type 'StampOptions': mode, targetSelector, comment, metaTag\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "9",
            "10"
          ],
          "location": {
            "end": {
              "column": 4,
              "line": 38
            },
            "start": {
              "column": 10,
              "line": 33
            }
          }
        },
        {
          "id": "57",
          "mutatorName": "BlockStatement",
          "replacement": "{}",
          "statusReason": "src/utils/utils.ts(32,57): error TS2355: A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.\n",
          "status": "CompileError",
          "static": false,
          "coveredBy": [
            "9",
            "10"
          ],
          "location": {
            "end": {
              "column": 2,
              "line": 39
            },
            "start": {
              "column": 70,
              "line": 32
            }
          }
        }
      ],
      "source": "import { DEFAULT_STAMP_OPTIONS } from \"@/index.constants\";\nimport type { PartialStampOptions, StampCommentOptions, StampMetaTagOptions, StampOptions } from \"@/index.types\";\n\nfunction validateBrowserEnvironment(): void {\n  if (typeof window === \"undefined\" || typeof window.document === \"undefined\") {\n    throw new Error(\"This function can only be run in a browser environment.\");\n  }\n}\n\nfunction getTargetElement(targetSelector: string): Element {\n  const targetElement = window.document.querySelector(targetSelector);\n  if (!targetElement) {\n    throw new Error(`Target element not found: ${targetSelector}`);\n  }\n  return targetElement;\n}\n\nfunction getStampMetaTagOptions(options: PartialStampOptions): StampMetaTagOptions {\n  return {\n    ...DEFAULT_STAMP_OPTIONS.metaTag,\n    ...options.metaTag,\n  };\n}\n\nfunction getStampCommentOptions(options: PartialStampOptions): StampCommentOptions {\n  return {\n    ...DEFAULT_STAMP_OPTIONS.comment,\n    ...options.comment,\n  };\n}\n\nfunction getStampOptions(options: PartialStampOptions): StampOptions {\n  return {\n    ...DEFAULT_STAMP_OPTIONS,\n    ...options,\n    comment: getStampCommentOptions(options),\n    metaTag: getStampMetaTagOptions(options),\n  };\n}\n\nexport {\n  validateBrowserEnvironment,\n  getTargetElement,\n  getStampMetaTagOptions,\n  getStampCommentOptions,\n  getStampOptions,\n};"
    }
  },
  "schemaVersion": "1.0",
  "thresholds": {
    "high": 100,
    "low": 100,
    "break": 100
  },
  "testFiles": {
    "src/utils/utils.spec.ts": {
      "tests": [
        {
          "id": "0",
          "name": "Dev Stamp Utils validateBrowserEnvironment should throw an error when not in a browser environment because window is undefined."
        },
        {
          "id": "1",
          "name": "Dev Stamp Utils validateBrowserEnvironment should throw an error when not in a browser environment because document is undefined."
        },
        {
          "id": "2",
          "name": "Dev Stamp Utils validateBrowserEnvironment should not throw an error when in a browser environment."
        },
        {
          "id": "3",
          "name": "Dev Stamp Utils getTargetElement should throw an error when the target element is not found."
        },
        {
          "id": "4",
          "name": "Dev Stamp Utils getTargetElement should return the target element when it is found."
        },
        {
          "id": "5",
          "name": "Dev Stamp Utils getStampMetaTagOptions should return default meta tag options when no options are provided."
        },
        {
          "id": "6",
          "name": "Dev Stamp Utils getStampMetaTagOptions should override default meta tag options with provided options when called."
        },
        {
          "id": "7",
          "name": "Dev Stamp Utils getStampCommentOptions should return default comment options when no options are provided."
        },
        {
          "id": "8",
          "name": "Dev Stamp Utils getStampCommentOptions should override default comment options with provided options when called."
        },
        {
          "id": "9",
          "name": "Dev Stamp Utils getStampOptions should return default options when no options are provided."
        },
        {
          "id": "10",
          "name": "Dev Stamp Utils getStampOptions should override default options with provided options when called."
        }
      ],
      "source": "import { describe } from \"vitest\";\n\nimport type { PartialStampOptions, StampCommentOptions, StampMetaTagOptions, StampOptions } from \"@/index.types\";\nimport { DEFAULT_STAMP_OPTIONS } from \"@/index.constants\";\nimport { getStampCommentOptions, getStampMetaTagOptions, getStampOptions, getTargetElement, validateBrowserEnvironment } from \"@/utils/utils\";\n\ndescribe(\"Dev Stamp Utils\", () => {\n  describe(validateBrowserEnvironment, () => {\n    it(\"should throw an error when not in a browser environment because window is undefined.\", () => {\n      globalThis.window = undefined as unknown as typeof globalThis.window;\n\n      expect(() => validateBrowserEnvironment()).toThrow(\"This function can only be run in a browser environment.\");\n    });\n\n    it(\"should throw an error when not in a browser environment because document is undefined.\", () => {\n      globalThis.window = {} as unknown as typeof globalThis.window;\n\n      expect(() => validateBrowserEnvironment()).toThrow(\"This function can only be run in a browser environment.\");\n    });\n\n    it(\"should not throw an error when in a browser environment.\", () => {\n      globalThis.window = window as unknown as typeof globalThis.window;\n\n      expect(() => validateBrowserEnvironment()).not.toThrow();\n    });\n  });\n\n  describe(getTargetElement, () => {\n    it(\"should throw an error when the target element is not found.\", () => {\n      const targetSelector = \"#nonexistent\";\n\n      expect(() => getTargetElement(targetSelector)).toThrow(`Target element not found: ${targetSelector}`);\n    });\n\n    it(\"should return the target element when it is found.\", () => {\n      const targetSelector = \"h1\";\n      const targetElement = getTargetElement(targetSelector);\n\n      expect(targetElement.nodeName).toBe(\"H1\");\n    });\n  });\n\n  describe(getStampMetaTagOptions, () => {\n    it(\"should return default meta tag options when no options are provided.\", () => {\n      const result = getStampMetaTagOptions({});\n\n      expect(result).toStrictEqual(DEFAULT_STAMP_OPTIONS.metaTag);\n    });\n\n    it(\"should override default meta tag options with provided options when called.\", () => {\n      const customOptions: PartialStampOptions = {\n        metaTag: {\n          name: \"custom-name\",\n        },\n      };\n      const result = getStampMetaTagOptions(customOptions);\n      const expectedOptions: StampMetaTagOptions = {\n        ...DEFAULT_STAMP_OPTIONS.metaTag,\n        ...customOptions.metaTag,\n      };\n\n      expect(result).toStrictEqual<StampMetaTagOptions>(expectedOptions);\n    });\n  });\n\n  describe(getStampCommentOptions, () => {\n    it(\"should return default comment options when no options are provided.\", () => {\n      const result = getStampCommentOptions({});\n\n      expect(result).toStrictEqual(DEFAULT_STAMP_OPTIONS.comment);\n    });\n\n    it(\"should override default comment options with provided options when called.\", () => {\n      const customOptions: PartialStampOptions = {\n        comment: {\n          innerDisplay: \"block\",\n        },\n      };\n      const result = getStampCommentOptions(customOptions);\n      const expectedOptions: StampCommentOptions = {\n        ...DEFAULT_STAMP_OPTIONS.comment,\n        ...customOptions.comment,\n      };\n\n      expect(result).toStrictEqual<StampCommentOptions>(expectedOptions);\n    });\n  });\n\n  describe(getStampOptions, () => {\n    it(\"should return default options when no options are provided.\", () => {\n      const result = getStampOptions({});\n\n      expect(result).toStrictEqual<StampOptions>(DEFAULT_STAMP_OPTIONS);\n    });\n\n    it(\"should override default options with provided options when called.\", () => {\n      const customOptions: PartialStampOptions = {\n        targetSelector: \"#custom\",\n        metaTag: {},\n      };\n      const result = getStampOptions(customOptions);\n      const expectedOptions: StampOptions = {\n        ...DEFAULT_STAMP_OPTIONS,\n        ...customOptions,\n        comment: DEFAULT_STAMP_OPTIONS.comment,\n        metaTag: {\n          ...DEFAULT_STAMP_OPTIONS.metaTag,\n          ...customOptions.metaTag,\n        },\n      };\n\n      expect(result).toStrictEqual<StampOptions>(expectedOptions);\n    });\n  });\n});"
    },
    "src/modes/meta-tag/meta-tag.spec.ts": {
      "tests": [
        {
          "id": "11",
          "name": "Meta Tag Mode stampOnExistingMetaTag should set the content attribute of the existing meta tag to the message when overwrite is true."
        },
        {
          "id": "12",
          "name": "Meta Tag Mode stampOnExistingMetaTag should log an error when overwrite is false."
        },
        {
          "id": "13",
          "name": "Meta Tag Mode stampMetaTagInHtml should create a new meta tag with the message when there is no existing meta tag."
        },
        {
          "id": "14",
          "name": "Meta Tag Mode stampMetaTagInHtml should create a new meta tag when called."
        },
        {
          "id": "15",
          "name": "Meta Tag Mode stampMetaTagInHtml should create a new meta tag with the personalized name when set in options."
        },
        {
          "id": "16",
          "name": "Meta Tag Mode stampMetaTagInHtml should create a new meta tag with the message as content when called."
        },
        {
          "id": "17",
          "name": "Meta Tag Mode stampMetaTagInHtml should call stampOnExistingMetaTag when there is an existing meta tag."
        }
      ],
      "source": "import { DEFAULT_STAMP_OPTIONS } from \"@/index.constants\";\nimport { stampMetaTagInHtml, stampOnExistingMetaTag } from \"@/modes/meta-tag/meta-tag\";\n\ndescribe(\"Meta Tag Mode\", () => {\n  describe(stampOnExistingMetaTag, () => {\n    it(\"should set the content attribute of the existing meta tag to the message when overwrite is true.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const existingMetaTag = document.createElement(\"meta\");\n      const options = { name: \"description\", overwrite: true };\n      const setAttributeSpy = vi.spyOn(existingMetaTag, \"setAttribute\");\n      stampOnExistingMetaTag(message, existingMetaTag, options);\n\n      expect(setAttributeSpy).toHaveBeenCalledExactlyOnceWith(\"content\", message);\n    });\n\n    it(\"should log an error when overwrite is false.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const existingMetaTag = document.createElement(\"meta\");\n      const options = { name: \"description\", overwrite: false };\n      const consoleErrorSpy = vi.spyOn(console, \"error\").mockImplementation(vi.fn());\n      stampOnExistingMetaTag(message, existingMetaTag, options);\n\n      expect(consoleErrorSpy).toHaveBeenCalledExactlyOnceWith(`Meta tag with name \"${options.name}\" already exists. Use \"overwrite\" option to replace it.`);\n    });\n  });\n\n  describe(stampMetaTagInHtml, () => {\n    it(\"should create a new meta tag with the message when there is no existing meta tag.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const { head } = window.document;\n      const appendChildSpy = vi.spyOn(head, \"appendChild\");\n      const appendedMetaTag = window.document.createElement(\"meta\");\n      appendedMetaTag.setAttribute(\"name\", DEFAULT_STAMP_OPTIONS.metaTag.name);\n      appendedMetaTag.setAttribute(\"content\", message);\n      stampMetaTagInHtml(message, DEFAULT_STAMP_OPTIONS);\n\n      expect(appendChildSpy).toHaveBeenCalledExactlyOnceWith(appendedMetaTag);\n    });\n\n    it(\"should create a new meta tag when called.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const { head } = window.document;\n      const appendChildSpy = vi.spyOn(head, \"appendChild\");\n      stampMetaTagInHtml(message, DEFAULT_STAMP_OPTIONS);\n      const appendedElement = appendChildSpy.mock.calls[0][0] as HTMLMetaElement;\n\n      expect(appendedElement.tagName).toBe(\"META\");\n    });\n\n    it(\"should create a new meta tag with the personalized name when set in options.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const { head } = window.document;\n      const appendChildSpy = vi.spyOn(head, \"appendChild\");\n      const customName = \"custom-name\";\n      const customOptions = {\n        ...DEFAULT_STAMP_OPTIONS,\n        metaTag: { ...DEFAULT_STAMP_OPTIONS.metaTag, name: customName },\n      };\n      stampMetaTagInHtml(message, customOptions);\n      const appendedElement = appendChildSpy.mock.calls[0][0] as HTMLMetaElement;\n\n      expect(appendedElement.getAttribute(\"name\")).toBe(customName);\n    });\n\n    it(\"should create a new meta tag with the message as content when called.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const { head } = window.document;\n      const appendChildSpy = vi.spyOn(head, \"appendChild\");\n      stampMetaTagInHtml(message, DEFAULT_STAMP_OPTIONS);\n      const appendedElement = appendChildSpy.mock.calls[0][0] as HTMLMetaElement;\n\n      expect(appendedElement.getAttribute(\"content\")).toBe(message);\n    });\n\n    it(\"should call stampOnExistingMetaTag when there is an existing meta tag.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const { head } = window.document;\n      const existingMetaTag = window.document.createElement(\"meta\");\n      existingMetaTag.setAttribute(\"name\", DEFAULT_STAMP_OPTIONS.metaTag.name);\n      head.appendChild(existingMetaTag);\n      stampMetaTagInHtml(message, DEFAULT_STAMP_OPTIONS);\n\n      expect(existingMetaTag.getAttribute(\"content\")).toBe(message);\n    });\n  });\n});"
    },
    "src/modes/comment/comment.spec.ts": {
      "tests": [
        {
          "id": "18",
          "name": "Comment Mode getFormattedComment should return the message as is when innerDisplay is 'inline'."
        },
        {
          "id": "19",
          "name": "Comment Mode getFormattedComment should return the message with leading and trailing spaces when innerDisplay is 'spaced-inline'."
        },
        {
          "id": "20",
          "name": "Comment Mode getFormattedComment should return the message with leading and trailing newlines when innerDisplay is 'block'."
        },
        {
          "id": "21",
          "name": "Comment Mode stampCommentInHtml should get the target element when called."
        },
        {
          "id": "22",
          "name": "Comment Mode stampCommentInHtml should create comment node with the message when called."
        },
        {
          "id": "23",
          "name": "Comment Mode stampCommentInHtml should append a comment node to the target element when called."
        },
        {
          "id": "24",
          "name": "Comment Mode stampCommentInHtml should append a comment node with the message specified in first argument to the target element when called."
        }
      ],
      "source": "import { Node } from \"happy-dom\";\n\nimport type { StampCommentOptions } from \"@/index.types\";\nimport { DEFAULT_STAMP_OPTIONS } from \"@/index.constants\";\nimport * as Utils from \"@/utils/utils\";\nimport { stampCommentInHtml, getFormattedComment } from \"@/modes/comment/comment\";\n\ndescribe(\"Comment Mode\", () => {\n  beforeEach(() => {\n    vi.spyOn(Utils, \"getTargetElement\").mockReturnValue(document.createElement(\"body\"));\n  });\n\n  describe(getFormattedComment, () => {\n    it(\"should return the message as is when innerDisplay is 'inline'.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const options: StampCommentOptions = { innerDisplay: \"inline\" };\n      const formattedMessage = getFormattedComment(message, options);\n\n      expect(formattedMessage).toBe(message);\n    });\n\n    it(\"should return the message with leading and trailing spaces when innerDisplay is 'spaced-inline'.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const options: StampCommentOptions = { innerDisplay: \"spaced-inline\" };\n      const formattedMessage = getFormattedComment(message, options);\n\n      expect(formattedMessage).toBe(` ${message} `);\n    });\n\n    it(\"should return the message with leading and trailing newlines when innerDisplay is 'block'.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const options: StampCommentOptions = { innerDisplay: \"block\" };\n      const formattedMessage = getFormattedComment(message, options);\n\n      expect(formattedMessage).toBe(`\\n${message}\\n`);\n    });\n  });\n\n  describe(stampCommentInHtml, () => {\n    it(\"should get the target element when called.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      stampCommentInHtml(message, DEFAULT_STAMP_OPTIONS);\n\n      expect(Utils.getTargetElement).toHaveBeenCalledWith(DEFAULT_STAMP_OPTIONS.targetSelector);\n    });\n\n    it(\"should create comment node with the message when called.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const targetElement = window.document.querySelector(\"body\");\n      const commentNode = window.document.createComment(message);\n      const appendChildSpy = vi.spyOn(targetElement as Element, \"appendChild\");\n      vi.spyOn(Utils, \"getTargetElement\").mockReturnValue(targetElement as Element);\n      stampCommentInHtml(message, DEFAULT_STAMP_OPTIONS);\n\n      expect(appendChildSpy).toHaveBeenCalledWith(commentNode);\n    });\n\n    it(\"should append a comment node to the target element when called.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const targetElement = window.document.querySelector(\"body\");\n      const appendChildSpy = vi.spyOn(targetElement as Element, \"appendChild\");\n      vi.spyOn(Utils, \"getTargetElement\").mockReturnValue(targetElement as Element);\n      stampCommentInHtml(message, DEFAULT_STAMP_OPTIONS);\n      const appendedNode = appendChildSpy.mock.calls[0][0] as Comment;\n\n      expect(appendedNode.nodeType).toBe(Node.COMMENT_NODE);\n    });\n\n    it(\"should append a comment node with the message specified in first argument to the target element when called.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const targetElement = window.document.querySelector(\"body\");\n      const appendChildSpy = vi.spyOn(targetElement as Element, \"appendChild\");\n      vi.spyOn(Utils, \"getTargetElement\").mockReturnValue(targetElement as Element);\n      stampCommentInHtml(message, DEFAULT_STAMP_OPTIONS);\n      const appendedNode = appendChildSpy.mock.calls[0][0] as Comment;\n\n      expect(appendedNode.textContent).toBe(message);\n    });\n  });\n});"
    },
    "src/index.spec.ts": {
      "tests": [
        {
          "id": "25",
          "name": "Dev Stamp Index stampInHtml should validate the browser environment when called."
        },
        {
          "id": "26",
          "name": "Dev Stamp Index stampInHtml should call the comment mode when the mode is comment."
        },
        {
          "id": "27",
          "name": "Dev Stamp Index stampInHtml should call the meta tag mode when the mode is meta-tag."
        },
        {
          "id": "28",
          "name": "Dev Stamp Index stampInHtml should log an error when one of the stamp methods throws an error."
        }
      ],
      "source": "import { describe } from \"vitest\";\n\nimport type { StampOptions } from \"@/index\";\nimport { stampInHtml } from \"@/index\";\nimport { DEFAULT_STAMP_OPTIONS } from \"@/index.constants\";\nimport * as CommentMode from \"@/modes/comment/comment\";\nimport * as MetaTagMode from \"@/modes/meta-tag/meta-tag\";\nimport * as Utils from \"@/utils/utils\";\n\ndescribe(\"Dev Stamp Index\", () => {\n  describe(stampInHtml, () => {\n    beforeEach(() => {\n      vi.spyOn(CommentMode, \"stampCommentInHtml\").mockImplementation(vi.fn());\n      vi.spyOn(MetaTagMode, \"stampMetaTagInHtml\").mockImplementation(vi.fn());\n      vi.spyOn(Utils, \"getStampOptions\").mockReturnValue(DEFAULT_STAMP_OPTIONS);\n      vi.spyOn(Utils, \"validateBrowserEnvironment\").mockImplementation(vi.fn());\n    });\n\n    it(\"should validate the browser environment when called.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      stampInHtml(message, DEFAULT_STAMP_OPTIONS);\n\n      expect(Utils.validateBrowserEnvironment).toHaveBeenCalledExactlyOnceWith();\n    });\n\n    it(\"should call the comment mode when the mode is comment.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const options: StampOptions = { ...DEFAULT_STAMP_OPTIONS, mode: \"comment\" };\n      stampInHtml(message, options);\n\n      expect(CommentMode.stampCommentInHtml).toHaveBeenCalledExactlyOnceWith(message, options);\n    });\n\n    it(\"should call the meta tag mode when the mode is meta-tag.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const options: StampOptions = { ...DEFAULT_STAMP_OPTIONS, mode: \"meta-tag\" };\n      vi.spyOn(Utils, \"getStampOptions\").mockReturnValue(options);\n      stampInHtml(message, options);\n\n      expect(MetaTagMode.stampMetaTagInHtml).toHaveBeenCalledExactlyOnceWith(message, options);\n    });\n\n    it(\"should log an error when one of the stamp methods throws an error.\", () => {\n      const message = \"Hello Dark Jess' ðŸª„\";\n      const options: StampOptions = { ...DEFAULT_STAMP_OPTIONS, mode: \"comment\" };\n      const errorMessage = \"Test error\";\n      vi.spyOn(CommentMode, \"stampCommentInHtml\").mockImplementation(() => {\n        throw new Error(errorMessage);\n      });\n      const consoleErrorSpy = vi.spyOn(console, \"error\").mockImplementation(vi.fn());\n      stampInHtml(message, options);\n\n      expect(consoleErrorSpy).toHaveBeenCalledWith(new Error(errorMessage));\n    });\n  });\n});"
    }
  },
  "projectRoot": "/Users/mac-Z14AZANA/WebstormProjects/dev-stamp",
  "config": {
    "cleanTempDir": "always",
    "incremental": true,
    "incrementalFile": "tests/stryker/incremental/incremental.json",
    "checkers": [
      "typescript"
    ],
    "tsconfigFile": "tsconfig.json",
    "testRunner": "vitest",
    "ignoreStatic": true,
    "plugins": [
      "@stryker-mutator/vitest-runner",
      "@stryker-mutator/typescript-checker"
    ],
    "ignorePatterns": [
      ".github/",
      ".husky/",
      ".run/",
      ".idea/",
      "dist/",
      "config/commitlint",
      "config/cucumber",
      "config/eslint",
      "config/lint-staged",
      "config/stryker",
      "tests/stryker",
      "tests/unit/coverage",
      "scripts/",
      "server/",
      ".editorconfig",
      ".npmrc",
      ".nvmrc",
      "release.config.mjs",
      ".DS_Store",
      ".validate-branch-namerc.json",
      "CHANGELOG.md",
      "LICENSE",
      "pnpm-lock.yaml",
      "sonar-project.properties",
      "README.md",
      "eslint.config.ts"
    ],
    "vitest": {
      "configFile": "config/vitest/vitest.global-unit-tests-config.ts"
    },
    "reporters": [
      "clear-text",
      "progress",
      "html",
      "json"
    ],
    "htmlReporter": {
      "fileName": "tests/stryker/coverage/index.html"
    },
    "jsonReporter": {
      "fileName": "tests/stryker/coverage/mutation.json"
    },
    "thresholds": {
      "high": 100,
      "low": 100,
      "break": 100
    },
    "dryRunTimeoutMinutes": 10,
    "disableTypeChecks": true,
    "packageManager": "pnpm",
    "configFile": "config/stryker/stryker.conf.mjs",
    "allowConsoleColors": true,
    "checkerNodeArgs": [],
    "commandRunner": {
      "command": "npm test"
    },
    "coverageAnalysis": "perTest",
    "clearTextReporter": {
      "allowColor": true,
      "allowEmojis": false,
      "logTests": true,
      "maxTestsToLog": 3,
      "reportTests": true,
      "reportMutants": true,
      "reportScoreTable": true,
      "skipFull": false
    },
    "dashboard": {
      "baseUrl": "https://dashboard.stryker-mutator.io/api/reports",
      "reportType": "full"
    },
    "dryRunOnly": false,
    "eventReporter": {
      "baseDir": "reports/mutation/events"
    },
    "force": false,
    "fileLogLevel": "off",
    "inPlace": false,
    "logLevel": "info",
    "maxConcurrentTestRunners": 9007199254740991,
    "maxTestRunnerReuse": 0,
    "mutate": [
      "{src,lib}/**/!(*.+(s|S)pec|*.+(t|T)est).+(cjs|mjs|js|ts|mts|cts|jsx|tsx|html|vue|svelte)",
      "!{src,lib}/**/__tests__/**/*.+(cjs|mjs|js|ts|mts|cts|jsx|tsx|html|vue|svelte)"
    ],
    "mutator": {
      "plugins": null,
      "excludedMutations": []
    },
    "appendPlugins": [],
    "symlinkNodeModules": true,
    "tempDirName": ".stryker-tmp",
    "testRunnerNodeArgs": [],
    "timeoutFactor": 1.5,
    "timeoutMS": 5000,
    "warnings": true,
    "disableBail": false,
    "allowEmpty": false,
    "ignorers": [],
    "typescriptChecker": {
      "prioritizePerformanceOverAccuracy": true
    }
  },
  "framework": {
    "name": "StrykerJS",
    "version": "9.0.1",
    "branding": {
      "homepageUrl": "https://stryker-mutator.io",
      "imageUrl": "data:image/svg+xml;utf8,%3Csvg viewBox='0 0 1458 1458' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath d='M1458 729c0 402.655-326.345 729-729 729S0 1131.655 0 729C0 326.445 326.345 0 729 0s729 326.345 729 729' fill='%23e74c3c' fill-rule='nonzero'/%3E%3Cpath d='M778.349 1456.15L576.6 1254.401l233-105 85-78.668v-64.332l-257-257-44-187-50-208 251.806-82.793L1076.6 389.401l380.14 379.15c-19.681 367.728-311.914 663.049-678.391 687.599z' fill-opacity='.3'/%3E%3Cpath d='M753.4 329.503c41.79 0 74.579 7.83 97.925 25.444 23.571 18.015 41.69 43.956 55.167 77.097l11.662 28.679 165.733-58.183-14.137-32.13c-26.688-60.655-64.896-108.61-114.191-144.011-49.329-35.423-117.458-54.302-204.859-54.302-50.78 0-95.646 7.376-134.767 21.542-40.093 14.671-74.09 34.79-102.239 60.259-28.84 26.207-50.646 57.06-65.496 92.701-14.718 35.052-22.101 72.538-22.101 112.401 0 72.536 20.667 133.294 61.165 182.704 38.624 47.255 98.346 88.037 179.861 121.291 42.257 17.475 78.715 33.125 109.227 46.994 27.193 12.361 49.294 26.124 66.157 41.751 15.309 14.186 26.497 30.584 33.63 49.258 7.721 20.214 11.16 45.69 11.16 76.402 0 28.021-4.251 51.787-13.591 71.219-8.832 18.374-20.171 33.178-34.523 44.219-14.787 11.374-31.193 19.591-49.393 24.466-19.68 5.359-39.14 7.993-58.69 7.993-29.359 0-54.387-3.407-75.182-10.747-20.112-7.013-37.144-16.144-51.259-27.486-13.618-11.009-24.971-23.766-33.744-38.279-9.64-15.8-17.272-31.924-23.032-48.408l-10.965-31.376-161.669 60.585 10.734 30.124c10.191 28.601 24.197 56.228 42.059 82.748 18.208 27.144 41.322 51.369 69.525 72.745 27.695 21.075 60.904 38.218 99.481 51.041 37.777 12.664 82.004 19.159 132.552 19.159 49.998 0 95.818-8.321 137.611-24.622 42.228-16.471 78.436-38.992 108.835-67.291 30.719-28.597 54.631-62.103 71.834-100.642 17.263-38.56 25.923-79.392 25.923-122.248 0-54.339-8.368-100.37-24.208-138.32-16.29-38.759-38.252-71.661-65.948-98.797-26.965-26.418-58.269-48.835-93.858-67.175-33.655-17.241-69.196-33.11-106.593-47.533-35.934-13.429-65.822-26.601-89.948-39.525-22.153-11.868-40.009-24.21-53.547-37.309-11.429-11.13-19.83-23.678-24.718-37.664-5.413-15.49-7.98-33.423-7.98-53.577 0-40.883 11.293-71.522 37.086-90.539 28.443-20.825 64.985-30.658 109.311-30.658z' fill='%23f1c40f' fill-rule='nonzero'/%3E%3Cpath d='M720 0h18v113h-18zM1458 738v-18h-113v18h113zM720 1345h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E"
    },
    "dependencies": {
      "@stryker-mutator/typescript-checker": "9.0.1",
      "typescript": "5.8.3"
    }
  }
}